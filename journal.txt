=================================================
7/11/2021
-----------------------------------------------
TODO:
- begin running riscv-tests
	- figure out a way to get objdump output
	  to Verilog $readmemh format
**********************************************
- branches_tb has bug in generating BGE instructions
	- LI loading incorrect values
	- otherwise all conditional branches are a-okay
- set up GTKWave translate filter process for RISCV instructions
	- also created a few translate filter files for
	      easier debugging
- cloned riscv-tests to Toast repo
=================================================

=================================================
7/9/2021
-----------------------------------------------
TODO:
- Test all branches and jumps in simulation
**********************************************
- built riscv-tests on Ubuntu 
	- compiled riscv-tests, a lot of tests 
          need branches or jumps just to function

- wrote a task to mimic psuedo-instruction LI
	-  m = (imm << 20) >> 20; 
           k = ((imm - m) >> 12) << 12; 
	- LUI(rd, k), then ADDI(rd, m)

- wrote testbench to test LUI and LI
	- testbench writes random values to 
	  random registers
	- self-checking
	-> TODO: add functional coverage

- wrote testbench to test branches
	- task TEST_BRANCH writes random values based on 
	  input task (i.e. "BGE", "BEQ", etc) to randomly
          generated rd1 and rd2
	- self-checking, reports # of passes and fails
	- fails are reported along with time of failure

- BUGFIXES
	- PC module was not stopping on a pipeline stall
	- Hazard Detection was causing unnecessary stalls
	- Forwarding module did not have checks for whether
          instructions required forwarding
=================================================

=================================================
7/7/2021
-----------------------------------------------
TODO:
**********************************************
- Built riscv-tests using riscv32-unknown-elf
riscv32-unknown-elf-gcc -s <input.s>     -> compile 
riscv32-unknown-elf-objdump -D <input.o> -> examine assembly code
riscv32-unknown-elf-objcopy -O verilog <input.o> <output.vh> -> covert to verilog hex 

Now for an actual plan moving forward:
- Many riscv-tests tests need:
	- JAL/JALR
	- AUIPC
	- BEQ
	- BNEZ
I need to verify that these work in simulation, then
the goal is to try to get each test working.
Thus;
1) write directed tests for JAL, JALR, AUIPC, BEQ
2) simulate tests, verify baseline level of functionality
3) attempt to run riscv-tests, starting with simple.S
=================================================

=================================================
7/3/2021
-----------------------------------------------
TODO:
- implement JALR and remaining load/store instructions
- write testbenches for each instruction
**********************************************
- installed icarus verilog and gtkwave on Ubuntu
	- practiced with counter example
	- need to figure out how to write command file
          to test files in different directories
	- need to practice adding include directories 
	  to command file
	- need to learn how to translate data in GTKwave
	  for easier debugging (i.e. show instructions)
- modified IMEM module to load instruction data into
  every fourth address
- rebuilt riscv-gnu-toolchain to /usr/bin

=================================================


=================================================
7/2/2021
-----------------------------------------------
TODO:
- add test tasks for all currently implemented instructions
- implement JALR and remaining load/store instructions
**********************************************
- added test tasks for all currently implemented instructions


=================================================


=================================================
7/1/2021
-----------------------------------------------
TODO:
- update datapath diagram
- investigate testbench methods
**********************************************
- decided to abandon formal verification for now
- found example self-checking tests: https://github.com/4a1c0/RV32i-Verilog
- rewrote IMEM to allow testbench to write to array instead of reading from 
  text file
- wrote testbench for BEQ
	- fixed bug where branch generation in ID stage wasn't 
	  executing on the same cycle	
=================================================

=================================================
6/30/2021
-----------------------------------------------
TODO:
- make sure signals propagate correctly from stage to stage
  on each cycle before moving forward
- write basic test for branch / jump
- come up with basic memory interface for MEM stage
***********************************************
- added memory interface based on Xilinx Dual Port Block Memory (no AXI)
- added WB stage
- implemented MEM and WB stages into pipeline
- core is synthesizable
- wrote basic testbench for simulation
-> verifying via simulation will take wayyyyy too long and is too much work!
	-> going to have to learn how to use RVFI
=================================================




=================================================
6/29/2021
-----------------------------------------------
TODO:
- document hazard detection and forwarding changes
- general documentation
- look into RISC-V tests repo
- iverilog/verilator 
***********************************************
- setup RISC-V tests in WSL2
- wrote basic testbench for existing pipeline components
- simulated in Vivado XSim, fixed minor bugs
=================================================




=================================================
6/28/2021
------------------------------------------------
TODO:
- pipeline control signals for EX stage
- hazard detection stall
- forwarding
************************************************
- Implemented pipeline EX register
- Implemented load hazard detection 
   -> Hazard_detection should deassert all control signals, 
      inserting a NOP when an instruction from IF depends on 
      an OPCODE_LOAD instruction from ID

- Implemented control hazard detection
   -> Hazard_detection assumes branch not taken
   -> If a branch is taken, flush IF, ID, EX stages 
   -> If a jump is taken, flush IF and ID stages

- Implemented data hazard detection
   -> Forwarding module should detect when an instruction in
      ID stage depends on the result of an instruction
      in EX or MEM stage and mux in the data early, see truth table

- Moved Branch_gen from EX stage to ID stage
   -> Will reduce cost of jumps
=================================================




=================================================
6/27/2021
------------------------------------------------
TODO: 
- pipeline control signals for EX stage
- hazard detection stall
- forwarding
*********************************************
- Installed Windows Subsystem for Linux 2
- Installed bronzebeard assembler
- Installed Ubuntu 18.04 on WSL2
=================================================




=================================================
6/26/2021
*********************************************
Implemented Decoder/Control for ID pipeline stage

- ALU_source_sel -> alu gets regfile data or imm
- ALU_op -> alu operation to perform
- Branch_op -> branch gen operation to perform- Branch_flag -> branch on ALU 'set' or 'not set'
- Mem_wr_en -> enable data mem write
- Mem_rd_en -> enable data mem read
- RegFile_wr_en -> enable regfile writeback
- MemToReg -> enable regfile writeback from data mem
- Jump -> JAL or JALR unconditional branch
- Mem_op -> select memory mask for load/store byte/half-word/word

Implemented Control Signals for following OPCODES:
- OP
- IMM
- BRANCH
- LUI
- AUIPC
- JAL
- JALR
- LOAD
- STORE
=================================================
